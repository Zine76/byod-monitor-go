// script.js

// MODIFICATION : D√©finir l'URL de base de votre backend Go
// Si votre backend Go tourne toujours localement pendant que vous testez GitHub Pages :
const backendBaseUrl = 'http://localhost:5050';
// Si vous d√©ployez un jour votre backend Go sur un serveur public/interne,
// vous changerez cette URL ici. Par exemple :
// const backendBaseUrl = 'https://mon-serveur-uqam.ca/api_byod';

let currentDevice = null;
let devices = []; // Initialiser comme un tableau vide

async function fetchDevicesAndInitialize() {
  try {
    // MODIFICATION : Utiliser backendBaseUrl
    const response = await fetch(`${backendBaseUrl}/api/devices`);
    if (!response.ok) {
      throw new Error(`Erreur HTTP ${response.status} lors de la r√©cup√©ration des appareils depuis ${backendBaseUrl}/api/devices`);
    }
    const loadedDevices = await response.json();
    devices = loadedDevices.map(d => ({
      ...d, 
      ip: d.ip || null, 
      status: d.status || null,
      rebootInitiatedAt: d.rebootInitiatedAt || null,
      isRebooting: d.isRebooting || false,
      lastSeen: d.lastSeen || null
    }));
    console.log("‚úÖ Appareils charg√©s depuis le backend:", devices);
  } catch (error) {
    console.error("‚ùå Impossible de charger la liste des appareils depuis le backend:", error);
    alert("Erreur: Impossible de charger la liste des appareils. V√©rifiez la console du backend et que le fichier appareils.csv existe et est correct. Assurez-vous aussi que le backend est accessible √† l'URL configur√©e.");
    devices = []; 
  }
  initializeMonitoring(); 
}

function initializeMonitoring() {
  console.log("üöÄ Initialisation du monitoring...");
  const buildings = new Set();
  const techs = new Set();
  devices.forEach(d => {
    if (d.building) buildings.add(d.building);
    if (d.tech) techs.add(d.tech);
  });

  const buildingFilter = document.getElementById("filter-building");
  buildingFilter.innerHTML = '<option value="">Tous les pavillons</option>';
  buildings.forEach(b => {
    const o = document.createElement('option');
    o.value = b; o.textContent = `Pavillon ${b}`;
    buildingFilter.appendChild(o);
  });

  const techFilter = document.getElementById("filter-tech");
  techFilter.innerHTML = '<option value="">Toutes les technologies</option>';
  techs.forEach(t => {
    const o = document.createElement('option');
    o.value = t; o.textContent = t;
    techFilter.appendChild(o);
  });
  console.log("üî© Filtres peupl√©s.");

  const rebootButtonElement = document.querySelector('#sidebar button.btn:nth-of-type(2)');
  if (rebootButtonElement && rebootButtonElement.innerText.toLowerCase().includes('rebooter')) {
      rebootButtonElement.classList.add('reboot-btn'); 
  }

  resolveAllIPs(() => {
    console.log("üìû R√©solution IP initiale termin√©e, lancement de la premi√®re mise √† jour des statuts.");
    updateStatuses(); 
    setInterval(updateStatuses, 7000); 
    setInterval(() => resolveAllIPs(null, true), 300000); 
  }, false);

  ["search", "filter-building", "filter-tech", "filter-status"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener(id === "search" ? "input" : "change", renderDevices);
  });
  console.log("üëÇ √âcouteurs d'√©v√©nements pour les filtres activ√©s.");
}

function resolveAllIPs(callback, isPeriodicCall = false) {
  if (!isPeriodicCall) console.log("‚ÑπÔ∏è D√©but de resolveAllIPs (appel initial)...");
  let pending = devices.length;
  if (pending === 0) {
    if (typeof callback === 'function' && !isPeriodicCall) callback();
    else if (isPeriodicCall) renderDevices();
    return;
  }
  devices.forEach(device => {
    // MODIFICATION : Utiliser backendBaseUrl
    fetch(`${backendBaseUrl}/resolve?host=${device.address}`)
      .then(r => {
        if (!r.ok) return r.json().then(eD => { throw new Error(`HTTP ${r.status}: ${eD.error||r.statusText}`) }).catch(()=> {throw new Error(`HTTP ${r.status}: ${r.statusText}`)});
        return r.json();
      }).then(data => {
        if (data && data.success && data.address) {
          if (device.ip !== data.address) device.ip = data.address;
        } else if (device.ip === null || !isPeriodicCall) device.ip = "Inconnu (√©chec r√©solution)";
      }).catch(err => {
        if (device.ip === null || !isPeriodicCall) device.ip = "Inconnu (erreur fetch)";
        console.warn(`Erreur r√©solution IP pour ${device.address}:`, err.message);
      }).finally(() => {
        pending--;
        if (pending === 0) {
          if (typeof callback === 'function' && !isPeriodicCall) {
            if (!isPeriodicCall) console.log("‚úÖ Toutes les r√©solutions d'IP initiales termin√©es.");
            callback();
          } else if (isPeriodicCall) {
            renderDevices();
            if (currentDevice && document.getElementById("sidebar").classList.contains("open")) {
              const updatedDevice = devices.find(d => d.address === currentDevice.address);
              if (updatedDevice && updatedDevice.ip !== document.getElementById("detail-ip").innerText) {
                openSidebar(updatedDevice);
              }
            }
          }
        }
      });
  });
}

function renderDevices() {
  const container = document.getElementById('status-container');
  if (!container) return; 
  container.innerHTML = "";
  
  const search = document.getElementById("search").value.toLowerCase();
  const fb = document.getElementById("filter-building").value;
  const ft = document.getElementById("filter-tech").value;
  const fsVal = document.getElementById("filter-status").value;

  devices.forEach(d => {
    const currentStatus = d.isRebooting ? "rebooting" : (d.status || "offline");
    if (fsVal && currentStatus !== fsVal) return;
    if (!d.status && !d.isRebooting && fsVal !== "offline" && fsVal !== "") return;

    const textContentForSearch = [d.name, d.building, d.tech, d.ip, d.mac].filter(Boolean).join(" ").toLowerCase();
    if (search && !textContentForSearch.includes(search)) return;
    if (fb && d.building !== fb) return;
    if (ft && d.tech !== ft) return;

    const box = document.createElement('div');
    box.className = `status-box ${currentStatus}`;
    box.innerHTML = `<div>${d.name}</div><div class="badge">${d.tech} ‚Ä¢ ${d.building}</div>`;
    box.onclick = () => openSidebar(d);
    container.appendChild(box);
  });
}

function updateStatuses() {
  // La fonction updateStatuses actuelle fait des fetch directs aux adresses des appareils (`http://${d.address}`)
  // pour simuler un ping. Ceci NE fonctionnera PAS depuis une page GitHub Pages
  // vers des adresses sur ton r√©seau local ou des adresses ddns.uqam.ca √† cause de CORS
  // et du fait que ce sont des requ√™tes cross-origin depuis un contexte s√©curis√© (HTTPS GitHub Pages)
  // vers des contextes potentiellement non s√©curis√©s (HTTP) ou des r√©seaux priv√©s.

  // Pour que cela fonctionne avec GitHub Pages, la V√âRIFICATION DE STATUT doit √™tre faite
  // par le BACKEND GO (ce que nous avons d√©j√† impl√©ment√© avec checkDeviceStatus).
  // Le frontend (script.js) doit alors seulement R√âCUP√âRER les statuts mis √† jour depuis le backend.

  // **Modification n√©cessaire pour updateStatuses avec GitHub Pages :**
  // Au lieu de faire des fetch directs, on devrait appeler /api/devices p√©riodiquement
  // pour obtenir les statuts mis √† jour par le serveur.
  // Ou, si fetchDevicesAndInitialize est appel√© p√©riodiquement, cela suffit.

  // Pour l'instant, je vais laisser la logique de PING CLIENT comment√©e
  // car elle ne fonctionnera pas de mani√®re fiable depuis GitHub Pages vers tes appareils.
  // Le statut affich√© d√©pendra de ce qui est r√©cup√©r√© par fetchDevicesAndInitialize
  // et mis √† jour par le backend Go.

  // Si tu veux un rafra√Æchissement plus fr√©quent des donn√©es du backend sans recharger toute la page :
  // Il faudrait que fetchDevicesAndInitialize soit appel√©e p√©riodiquement, 
  // ou un nouvel endpoint qui renvoie juste les mises √† jour.
  // Pour la simplicit√©, on va se baser sur le fait que `startStatusScheduler` dans Go met √† jour
  // `cachedDevices`, et `fetchDevicesAndInitialize` est appel√© au chargement.
  // Pour un refresh, il faudrait appeler √† nouveau fetchDevicesAndInitialize ou une partie.
  // console.log("Mise √† jour des statuts visuels via fetchDevicesAndInitialize (si appel√©e p√©riodiquement)");
  // Pour l'instant, cette fonction ne fera rien de plus si les pings client sont d√©sactiv√©s.
  // Les statuts seront ceux fournis par le backend lors du dernier fetchDevicesAndInitialize.
  // Le setInterval dans initializeMonitoring appelle d√©j√† cette fonction updateStatuses, 
  // mais elle ne fait plus de pings client.
  
  // Pour un vrai rafra√Æchissement depuis le backend sans recharger toute la page :
  // On pourrait appeler √† nouveau fetchDevicesAndInitialize (ou une version all√©g√©e)
  // mais cela re-remplirait les filtres, etc.
  // Pour le moment, le statut est mis √† jour en m√©moire par le backend Go.
  // Le frontend r√©cup√®re cet √©tat lors du chargement initial.
  // Pour voir les mises √† jour du backend, il faudrait rafra√Æchir la page
  // OU que `fetchDevicesAndInitialize` soit appel√©e par un `setInterval`.

  // **Pour un vrai rafra√Æchissement des donn√©es sans recharger la page**
  // Il est mieux d'appeler fetchDevicesAndInitialize dans un intervalle
  // MAIS cela va recharger TOUTE la liste et potentiellement r√©initialiser les filtres.
  // L'appel `updateStatuses` actuel dans `setInterval` ne fait plus de pings client,
  // donc il ne mettra pas √† jour les couleurs √† moins que `devices` soit mis √† jour autrement.

  // **Action pour cette fonction `updateStatuses` quand servie depuis GitHub Pages :**
  // Elle devrait probablement √™tre renomm√©e et appeler `fetchDevicesAndInitialize`
  // pour r√©cup√©rer l'√©tat le plus r√©cent du backend.
  // Cependant, pour √©viter de re-cr√©er les filtres √† chaque fois, on pourrait
  // juste mettre √† jour les donn√©es des `devices` et appeler `renderDevices()`.

  // **SOLUTION SIMPLIFI√âE pour l'instant pour le refresh depuis le backend :**
  // On va modifier `initializeMonitoring` pour appeler `fetchDevicesAndInitialize` p√©riodiquement.
  // Et `updateStatuses` ne fera plus rien, car les pings client ne sont pas fiables ici.
  // La source de v√©rit√© pour le statut est le backend.
  // renderDevices(); // Juste pour s'assurer que l'affichage est √† jour avec les donn√©es actuelles
}


// Modification dans initializeMonitoring pour rafra√Æchir depuis le backend
function initializeMonitoring() {
  console.log("üöÄ Initialisation du monitoring...");
  // ... (code pour peupler les filtres, inchang√©) ...
  const buildings = new Set();
  const techs = new Set();
  devices.forEach(d => {
    if (d.building) buildings.add(d.building);
    if (d.tech) techs.add(d.tech);
  });

  const buildingFilter = document.getElementById("filter-building");
  buildingFilter.innerHTML = '<option value="">Tous les pavillons</option>';
  buildings.forEach(b => {
    const o = document.createElement('option');
    o.value = b; o.textContent = `Pavillon ${b}`;
    buildingFilter.appendChild(o);
  });

  const techFilter = document.getElementById("filter-tech");
  techFilter.innerHTML = '<option value="">Toutes les technologies</option>';
  techs.forEach(t => {
    const o = document.createElement('option');
    o.value = t; o.textContent = t;
    techFilter.appendChild(o);
  });
  console.log("üî© Filtres peupl√©s.");

  const rebootButtonElement = document.querySelector('#sidebar button.btn:nth-of-type(2)');
  if (rebootButtonElement && rebootButtonElement.innerText.toLowerCase().includes('rebooter')) {
      rebootButtonElement.classList.add('reboot-btn'); 
  }
  // Fin du code pour peupler les filtres

  resolveAllIPs(() => { // Ceci appelle le backend pour les IPs
    console.log("üìû R√©solution IP initiale termin√©e.");
    // fetchDevicesAndInitialize a d√©j√† √©t√© appel√© une fois et a appel√© renderDevices via initializeMonitoring.
    // Maintenant, nous allons rafra√Æchir les donn√©es des appareils (qui incluent les statuts mis √† jour par le backend Go)
    // p√©riodiquement.
  }, false);

  // Remplacer l'ancien setInterval(updateStatuses, ...)
  // par un appel p√©riodique √† une fonction qui rafra√Æchit les donn√©es du backend.
  setInterval(async () => {
    console.log("üîÑ Rafra√Æchissement des donn√©es des appareils depuis le backend...");
    try {
      const response = await fetch(`${backendBaseUrl}/api/devices`);
      if (!response.ok) {
        console.error(`Erreur HTTP ${response.status} lors du rafra√Æchissement des appareils.`);
        return; // Ne pas continuer si erreur
      }
      const loadedDevices = await response.json();
      // Fusionner intelligemment les nouvelles donn√©es avec les anciennes pour ne pas perdre l'√©tat de `isRebooting` du client
      devices.forEach(existingDevice => {
        const updatedDeviceData = loadedDevices.find(ld => ld.address === existingDevice.address);
        if (updatedDeviceData) {
          existingDevice.status = updatedDeviceData.status;
          existingDevice.ip = updatedDeviceData.ip || existingDevice.ip; // Garder l'IP si la nouvelle est nulle
          existingDevice.lastSeen = updatedDeviceData.lastSeen;
          // Ne pas √©craser isRebooting ou rebootInitiatedAt ici, car g√©r√© par le client pour le visuel du reboot
        }
      });
      // Ajouter les nouveaux appareils qui n'existaient pas
      loadedDevices.forEach(ld => {
        if (!devices.some(d => d.address === ld.address)) {
          devices.push({ // S'assurer d'initialiser les champs client
            ...ld,
            isRebooting: false,
            rebootInitiatedAt: null
          });
        }
      });
      // Supprimer les appareils qui n'existent plus dans la source
      devices = devices.filter(d => loadedDevices.some(ld => ld.address === d.address));


      renderDevices(); // Mettre √† jour l'affichage avec les nouveaux statuts
    } catch (error) {
      console.error("‚ùå Erreur lors du rafra√Æchissement des appareils depuis le backend:", error);
    }
  }, 7000); // Rafra√Æchir les donn√©es du backend toutes les 7 secondes

  setInterval(() => resolveAllIPs(null, true), 300000); // R√©solution IP toutes les 5 minutes (inchang√©)

  ["search", "filter-building", "filter-tech", "filter-status"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener(id === "search" ? "input" : "change", renderDevices);
  });
  console.log("üëÇ √âcouteurs d'√©v√©nements pour les filtres activ√©s.");
}
// La fonction updateStatuses originale (avec les pings client) est maintenant effectivement remplac√©e
// par la logique de rafra√Æchissement dans setInterval de initializeMonitoring.


function openSidebar(d) {
  currentDevice = d; 
  document.getElementById("detail-name").innerText = d.name;
  document.getElementById("detail-ip").innerText   = d.ip   || "Inconnu";
  document.getElementById("detail-mac").innerText  = d.mac;
  document.getElementById("detail-time").innerText = d.lastSeen || "Non test√©"; // lastSeen vient du backend
  document.getElementById("detail-link").href      = `http://${d.address}`;

  const rebootButton = document.querySelector('#sidebar .reboot-btn');
  if (rebootButton) {
    rebootButton.disabled = !!d.isRebooting; 
  }
  document.getElementById("sidebar").classList.add("open");
}
function closeSidebar() { 
  document.getElementById("sidebar").classList.remove("open"); 
}
function copyToClipboard(id) {
  navigator.clipboard.writeText(document.getElementById(id).innerText)
    .then(() => console.log(`üìã Copi√©: ${document.getElementById(id).innerText}`))
    .catch(err => console.error('‚ùå Erreur copie:', err));
}

function rebootDevice() {
  if (!currentDevice) {
    console.warn("Tentative de reboot sans appareil s√©lectionn√©.");
    return;
  }
  if (currentDevice.isRebooting) {
    console.log(`‚ÑπÔ∏è Reboot pour ${currentDevice.name} d√©j√† en cours. Ignor√©.`);
    return;
  }

  const deviceToReboot = currentDevice; 
  console.log(`‚öôÔ∏è Tentative de reboot pour ${deviceToReboot.name} (${deviceToReboot.address})`);
  
  const rebootButton = document.querySelector('#sidebar .reboot-btn');
  if (rebootButton) rebootButton.disabled = true;
  
  deviceToReboot.isRebooting = true; 
  deviceToReboot.rebootInitiatedAt = new Date().getTime();
  renderDevices(); 

  // MODIFICATION : Utiliser backendBaseUrl
  fetch(`${backendBaseUrl}/reboot`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ host: deviceToReboot.address })
  }).then(r => {
    if (!r.ok) return r.json().then(eD => { throw new Error(`Erreur serveur ${r.status}: ${eD.error||'Erreur inconnue'}`) }).catch(()=> {throw new Error(`Erreur serveur ${r.status}`)});
    return r.json();
  }).then(resp => {
    if (!resp.success) throw new Error(resp.error || "√âchec de la commande de reboot c√¥t√© backend");
    alert(`‚úÖ Commande de reboot envoy√©e pour ${deviceToReboot.name} !`);
    console.log(`üéâ Commande reboot pour ${deviceToReboot.address} envoy√©e. Output du script:`, resp.output);
    // Pas besoin de forcer updateStatuses ici, le setInterval le fera.
    // On peut vouloir un fetch imm√©diat pour refl√©ter le statut "rebooting" du serveur
    setTimeout(async () => {
        const response = await fetch(`${backendBaseUrl}/api/devices`);
        const loadedDevices = await response.json();
        const updatedDeviceData = loadedDevices.find(ld => ld.address === deviceToReboot.address);
        if (updatedDeviceData) {
            deviceToReboot.status = updatedDeviceData.status; // Mettre √† jour avec le statut du serveur
        }
        renderDevices();
    }, 5000); // Attendre un peu que le serveur ait pu marquer en rebooting

  }).catch(e => {
    alert(`‚ùå √âchec envoi commande reboot pour ${deviceToReboot.name}: ` + e.message);
    console.error(`üí• √âchec requ√™te reboot pour ${deviceToReboot.address}: `, e.message);
    // Remettre isRebooting √† false si la commande elle-m√™me √©choue (avant m√™me d'atteindre le serveur ou si le serveur rejette)
    deviceToReboot.isRebooting = false;
    delete deviceToReboot.rebootInitiatedAt;
    if (rebootButton) rebootButton.disabled = false; // R√©activer le bouton imm√©diatement
    renderDevices();
  }).finally(() => {
      setTimeout(() => {
          if (rebootButton && deviceToReboot.isRebooting) { 
            console.warn(`Bouton de reboot pour ${deviceToReboot.name} r√©activ√© (timeout de s√©curit√©). isRebooting est toujours ${deviceToReboot.isRebooting}. V√©rifier l'√©tat de l'appareil.`);
            rebootButton.disabled = false; 
          } else if (rebootButton && !deviceToReboot.isRebooting) {
            // Si le reboot est termin√© (isRebooting = false), le bouton est d√©j√† r√©activ√© par openSidebar
            // mais on s'assure qu'il l'est.
             if (currentDevice && currentDevice.address === deviceToReboot.address) { // Seulement si c'est toujours l'appareil courant
                rebootButton.disabled = false;
             }
          }
      }, 90000); 
  });
}

window.onload = () => {
  fetchDevicesAndInitialize();
};
